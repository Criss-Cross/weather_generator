---
title: "Weather Generator"
author: "Sean Gibbon (19770237), Matthew Johnston (19777775), Mitchell Spencer (19034205), Sidra Nasir (18859261)"
date: "8 June 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 
# Report section:
=======

Do the report part here

=======

# Code:
=======

Link to data source: 
http://www.bom.gov.au/jsp/ncc/cdio/weatherData/av?p_nccObsCode=136&p_display_type=dailyDataFile&p_startYear=2019&p_c=-17059101&p_stn_num=009225

# Preliminary Setup 
```{r}
# Reading in the data from the csv file
data <-  read.csv("IDCJAC0009_009225_1800_Data.csv")
weather_data <- data
weather_data <- weather_data[which(is.na(weather_data$Rainfall.amount..millimetres.) == FALSE),]
```

```{r}
table(weather_data$Year, weather_data$Quality)
```

```{r}
weather_data$date <- do.call(paste, c(weather_data[c("Day", "Month", "Year")], sep = "-"))
```

```{r}
state <- function(x){
  stateList <- c()
  for(ii in 1:length(x)){
    if(x[ii] < 1){
      stateList <- c(stateList, "dry")
    }
    if(x[ii] >= 1){
      stateList <- c(stateList, "wet")
    }
  }
  return(stateList)
}
weather_data$state <- state(weather_data$Rainfall.amount..millimetres.)
```

```{r}
transitionState <- function(x){
  transitionStateList <- c('') #can't find transition state of first observation
  for(i in 2:length(x)){
    if(x[i] == "dry"){
      if (x[i-1] == "dry"){
        transitionStateList <- c(transitionStateList, "DryToDry")
      }
      else {
        transitionStateList <- c(transitionStateList, "WetToDry")
      }
    }
    if(x[i] == "wet"){
      if (x[i-1] == "dry"){
        transitionStateList <- c(transitionStateList, "DryToWet")
      }
      else {
        transitionStateList <- c(transitionStateList, "WetToWet")
      }
    }
  }
  return(transitionStateList)
}
weather_data$transitionState <- transitionState(weather_data$state)
```

```{r}
train_data <- subset(weather_data, Year >= 2010)
library(ggplot2)
library(RColorBrewer)

# Plotting the rainfall data (grouped by years and months)
ggplot(train_data, aes(x = factor(Month), y = Rainfall.amount..millimetres., fill = factor(Year))) + 
  geom_bar(stat = "identity") + 
  scale_fill_brewer(palette = "Paired") + 
  xlab("Month")+
  ylab("Rainfall (mm)")+
  labs(fill = "Year")+
  ggtitle("Rainfall of each month. Divided into Years")

ggplot(train_data, aes(x = factor(Year), y = Rainfall.amount..millimetres., fill = factor(Month))) + 
  geom_bar(stat = "identity") + 
  scale_fill_brewer(palette = "Paired") + 
  xlab("Year")+
  ylab("Rainfall (mm)")+
  labs(fill = "Month")+
  ggtitle("Rainfall of each Year. Divided into Months")
```
```{r}
table(train_data$Month, train_data$Year)
```

```{r}
#Calculating transition state probabilities, in general (no respect to month or season)
weatherTable <- table(train_data$transitionState)

probWetToWet = weatherTable['WetToWet'] / (weatherTable['WetToWet'] + weatherTable['WetToDry'])
probWetToWet

probDryToDry = weatherTable['DryToDry'] / (weatherTable['DryToDry'] + weatherTable['DryToWet'])
probDryToDry
```

```{r}
#Basic generator (No seasonal variation)

currentState = "dry" #can make this into a random choice later
                                              #choosing next state depending on probs calculated above
generateRainfallBasic <- function(genLength){
  rainAmountList <- c()
  for (i3 in 1:genLength){
    if (currentState == "dry"){
      if (runif(1) < probDryToDry){
        currentState = "dry"
      }
      else{
        currentState = "wet"
      }
    }
    else if (currentState == "wet"){
      if (runif(1) < probWetToWet){
        currentState = "wet"
      }
      else{
        currentState = "dry"
      }
    }
                                      #generating amount of rainfall if state is wet, else 0
    if (currentState == "wet"){
      rainAmount <- 5*exp(rnorm(1))
      rainAmountList <- c(rainAmountList, rainAmount)
    }
    else{
      rainAmountList <- c(rainAmountList, 0)
    }
  }
  return(rainAmountList)
}
```

```{r, fig.height=10}
#Basic generator tests
testRainfall = generateRainfallBasic(3761)
plot(testRainfall)

par(mfrow=c(2,1))
hist(train_data$Rainfall.amount..millimetres.[train_data$Rainfall.amount..millimetres.>1 & train_data$Rainfall.amount..millimetres.<50], xlab = "Actual Rainfall (mm)", main = "Actual Rainfall Frequency Histogram")
hist(testRainfall[testRainfall > 1 & testRainfall <50], xlab = "Simulated Rainfall (mm)", main = "Simulated Rainfall Frequency Histogram")

par(mfrow=c(2,1))
barplot(train_data$Rainfall.amount..millimetres., ylim = c(0,80), main = "Original Data", ylab = "Rainfall (mm)", xlab = "Index")
barplot(testRainfall, ylim = c(0,80), main = "Simulated Data", ylab = "Rainfall (mm)", xlab = "Index")
```

```{r}
#Calculates the transition probabilities for each month
transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #Initialises 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet')

#Makes the dataframe with the count of each transition state with each month
for (i4 in 1:dim(train_data)[1]){
  tempTransitionState <- train_data[i4, 'transitionState']
  tempMonth <- train_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```

```{r}
#Calculates the probabilities for each month in the data frame
probTransitonStatesMonthsFrame <- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
#How the transition state probabilities vary for each month
plot(probTransitonStatesMonthsFrame$DryToDry, ylim = c(0,1), xlab = "Month", main = "'dry to dry' transition state probability", type = 'l', ylab = "Probability")
plot(probTransitonStatesMonthsFrame$WetToWet, ylim = c(0,1), xlab = "Month", main = "'wet to wet' transition state probability", type = 'l', ylab = "Probability")
```
```{r}
#Weather generator accounting  for seasonal variation of transition states or something i hope
#Yes this is just a spicy version of basic generator it's mostly the same in fact if i forget to even do this it is the same

generateRainfallSeasonal <- function(input){
  currentState = "dry" #can make this into a random choice later
  rainAmountList <- c()
  for (i5 in 1:dim(input)[1]){
    if (currentState == "dry"){
      if (runif(1) < probTransitonStatesMonthsFrame[input[i5, 'Month'], 'DryToDry']){ #now inputs depending on the month of input
        currentState = "dry"
      }
      else{
        currentState = "wet"
      }
    }
    else if (currentState == "wet"){
      if (runif(1) < probTransitonStatesMonthsFrame[input[i5, 'Month'], 'WetToWet']){
        currentState = "wet"
      }
      else{
        currentState = "dry"
      }
    }
                                      #generating amount of rainfall if state is wet, else 0
    if (currentState == "wet"){
      rainAmount <- 5*exp(rnorm(1)) #now log-normal dist, 5 used because is close to mean of weather_data's / the mean of what exp(rnorm(1)) is by default
      rainAmountList <- c(rainAmountList, rainAmount)
    }
    else{
      rainAmountList <- c(rainAmountList, 0)
    }
  }
  return(rainAmountList)
}
```

```{r}
#testing code for seasonal generator
inputSeasonalRainfall <- dplyr::select(train_data, 'Year', 'Month', 'Day') #using existing train data's dates to input to function, instead of putting in just how many to generate

testSeasonalRainfall = generateRainfallSeasonal(inputSeasonalRainfall)
```

```{r}
par(mfrow=c(2,1))
barplot(train_data$Rainfall.amount..millimetres., ylim = c(0,80), main = "Original Data", ylab = "Rainfall (mm)", xlab = "Index")
barplot(testSeasonalRainfall, ylim = c(0,80), main = "Simulated Data - seasonal", ylab = "Rainfall (mm)", xlab = "Index")
```

```{r}
#comparing log-normal against actual data, veeerryyyy close fit, will use log-normal for rainfall sim
p1 <- 5*exp(rnorm(732))
p1 <- p1[p1>1]
hist(p1, breaks = 30, xlim = c(0,120), ylim = c(0,400), main = "Simulated distribution")

p2 <- train_data$Rainfall.amount..millimetres.[train_data$Rainfall.amount..millimetres.>1]
hist(p2, breaks = 30, xlim = c(0,120), ylim = c(0,400), main = "actual distribution")

```

# Testing with sampling - Testing on a percentage of the data

```{r}
set.seed(100345)

sampID <- sample.int(nrow(train_data), size = 0.5*nrow(train_data), replace = FALSE)
train_data <- train_data[sampID,] # 50% of data for training
test_data <- train_data[-sampID,] # 50% for testing
```

```{r}
#code to calculate transition probabilities for each month (copied from earlier)

transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #initialising frame by creating 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet') #name da columns

for (i4 in 1:dim(train_data)[1]){ #making dataframe with count of each transition state for each month
  tempTransitionState <- train_data[i4, 'transitionState']
  tempMonth <- train_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```

```{r}
#also copied from earlier
probTransitonStatesMonthsFrame<- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){ #calculating transition probs for each month in df
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
#generate test data
testSeasonalRainfall50 = generateRainfallSeasonal(train_data)
```
```{r}
par(mfrow = c(2, 1))

barplot(testSeasonalRainfall50, ylab = "Rainfall (mm)", xlab = "index", main = "Simulated data")
barplot(test_data$Rainfall.amount..millimetres., ylab = "Rainfall (mm)", xlab  = "index", main = "Actual data")
```

# Using the data from the previous 10 years (2009-2018) to predict the weather for the next year (2019)
```{r}
train_data <- subset(weather_data, Year >= 2010)
train10_data <- subset(weather_data, Year >= 2009 & Year < 2019)
data_2019 <- subset(weather_data, Year == 2019)
```

```{r}
#code to calculate transition probabilities for each month (copied from earlier)

transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #initialising frame by creating 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet') #name da columns

for (i4 in 1:dim(train10_data)[1]){ #making dataframe with count of each transition state for each month
  tempTransitionState <- train10_data[i4, 'transitionState']
  tempMonth <- train10_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```
```{r}
#also copied from earlier
probTransitonStatesMonthsFrame<- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){ #calculating transition probs for each month in df
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
# using month probabilites generate one years worth of data 
monthList <- subset(weather_data, Year == 2011) # a year that isn't a leap year to get the month list, as generation algorithm only requires months
monthList <- monthList['Month']
testSeasonalRainfall10 <- generateRainfallSeasonal(monthList)
```

```{r, fig.height=9}
#compare generated year against 2019
par(mfrow = c(2,1))
barplot(testSeasonalRainfall10, xlab = "Index", ylab = "Rainfall (mm)", main = "Simulated Rainfall")
barplot(data_2019$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2019 Rainfall")


# check other years for comparison
par(mfrow = c(3,2))
barplot(testSeasonalRainfall10, xlab = "Index", ylab = "Rainfall (mm)", main = "Simulated Rainfall")
year <- subset(weather_data, Year == 2015)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2015 Rainfall")
year <- subset(weather_data, Year == 2008)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2008 Rainfall")
year <- subset(weather_data, Year == 2017)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2017 Rainfall")
year <- subset(weather_data, Year == 2007)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2007 Rainfall")
year <- subset(weather_data, Year == 2013)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2013 Rainfall")
rm(year)
```

```{r}
temp <- subset(weather_data, weather_data$state == "wet")
mean(temp$Rainfall.amount..millimetres.)
rm(temp)
```


# Examining for patterns
```{r}
# Creates a graph of difference in rainfall for years, weeks, months, years to see if there are any potential patterns.

# Creates a list of the weekly rainfall
RainfallWeekly <- data.frame("Rainfall (mm)", "Week")
colnames(RainfallWeekly) <- c("Rainfall (mm)", "Week")
RainfallWeekly$`Rainfall (mm)` <- as.numeric(RainfallWeekly$`Rainfall (mm)`)
RainfallWeekly$Week <- as.numeric(RainfallWeekly$Week)
week = 1
weekRain = 0
for(ii in c(1: nrow(weather_data))){
  weekRain = weekRain + weather_data[ii, 6] # rainfall amount for that row
  
  if(ii%%7 == 0){ # every 7th row
    RainfallWeekly[(ii/7), 1] <- weekRain # 1 row of RainfallWeekly created every 7 rows (1 weeks) - inserting rainfall total for that week
    RainfallWeekly[(ii/7), 2] <- week
    week = week + 1
    weekRain = 0 # clear total rainfall to prepare for next week
  }
}
```

```{r}
RainfallWeeklyDiff <- data.frame(c(1:(nrow(RainfallWeekly)-1)), c(1:(nrow(RainfallWeekly)-1))) # data frame with two columns, one less row than RainfallWeekly
colnames(RainfallWeeklyDiff) <- c("Rainfall diff (mm)", "Week")
RainfallWeeklyDiff$`Rainfall diff (mm)` <- diff(RainfallWeekly$`Rainfall (mm)`) # change in weeks
```
```{r, fig.height= 14}
# plot first 700 weeks first against the difference in rainfall, and then the rainfall per week
par(mfrow = c(4,1))
plot(RainfallWeeklyDiff[c(1:350), 2], RainfallWeeklyDiff[c(1:350), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(1:350), 2], RainfallWeekly[c(1:350), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
plot(RainfallWeeklyDiff[c(351:700), 2], RainfallWeeklyDiff[c(351:700), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(351:700), 2], RainfallWeekly[c(351:700), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")

```

```{r, fig.height= 14}
# plot second 700 weeks first against the difference in rainfall, and then the rainfall per week
par(mfrow = c(4,1))
plot(RainfallWeeklyDiff[c(701:1050), 2], RainfallWeeklyDiff[c(701:1050), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(701:1050), 2], RainfallWeekly[c(701:1050), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
plot(RainfallWeeklyDiff[c(1051:1414), 2], RainfallWeeklyDiff[c(1051:1414), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(1051:1414), 2], RainfallWeekly[c(1051:1414), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
```

```{r}
rainSort_2019 <- data_2019$Rainfall.amount..millimetres.
# qqplot before removing 'dry' days
qqnorm(rainSort_2019, pch = 1, frame = F, main = "Normal Q-Q Plot of Rainfall 2019 (including dry days)")
qqline(rainSort_2019, col = "red", lwd = 2)
rainSort_2019 <- rainSort_2019[which(rainSort_2019 != 0)]
# qqplot after removing 'dry' days
qqnorm(rainSort_2019, pch = 1, frame = F, main = "Normal Q-Q Plot of Rainfall 2019 (excluding dry days)")
qqline(rainSort_2019, col = "red", lwd = 2)
hist(rainSort_2019, breaks = 50)
# data is not normally distributed
rm(rainSort_2019)
```


# Wilcoxon signed rank test on the data for 2019

```{r}
rain2019 <- subset(weather_data, Year == 2019)
length(rain2019$Rainfall.amount..millimetres.)
length(testSeasonalRainfall10)

table(rain2019$Month)
# Since there are two days missing from October and December, we will have to find the days and remove them from our simulated results.
table(rain2019$Day)
# one month is missing a day 5, and another is missing a day 19 (both 11 when should be 12)/
temp <- subset(rain2019, Day == 5)
temp$Month # 5th of October missing
temp <- subset(rain2019, Day == 19)
temp$Month # 19th of December missing
rm(temp)
```
```{r}
# To perform the Wilcoxon Signed Rank test we remove those dates from testSeasonalRainfall10
# 2019 is a non leap year so February will have 28 days
#October 5th and December 19th are missing, so we remove them
month_result <- which(rain2019$date == "4-10-2019" | rain2019$date=="18-12-2019")
simRainfall2019 <- testSeasonalRainfall10[-c(month_result[1]+1, month_result[2]+1)]

# Test of testSeasonalRainfall10 against 2019 rainfall (testSeasonalRainfall10 was simulation of 2019 rainfall)
wilcox.test(simRainfall2019, rain2019$Rainfall.amount..millimetres., paired = T, alternative = "t")

# Since the p-value is relatively high, it can be concluded that there is no significant diference between the simulated 2019 data and the actual 2019 data. 
# While the simulation may not be an accurate prediction of 2019 (as seen in the barplots), the simulation was also not logically flawed, as there is not a significant difference between the median of the simulation and the median of the actual.
#Furthermore, a qucik comparison of the medians in the Wilcoxon Signed Rank test shows that (as expected) they are also very similar.
cat("Median of actual and simulated rainfall respectively: ", median(rain2019$Rainfall.amount..millimetres.), median(simRainfall2019))
rm(simRainfall2019)
```


