---
title: "Weather Generator"
author: "Sean Gibbon (19770237), Matthew Johnston (19777775), Mitchell Spencer (19034205), Sidra Nasir (18859261)"
date: "8 June 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 

## Begin code:/
=======

Reading the data in from the csv file
```{r}
data <-  read.csv("IDCJAC0009_009225_1800_Data.csv")
weather_data <- data
weather_data <- weather_data[which(is.na(weather_data$Rainfall.amount..millimetres.) == FALSE),]
```

```{r}
range(weather_data$Year)
unique(weather_data$Bureau.of.Meteorology.station.number)
unique(weather_data$Product.code)
```
```{r}
table(weather_data$Year, weather_data$Quality)
```

```{r}
weather_data$date <- do.call(paste, c(weather_data[c("Day", "Month", "Year")], sep = "-"))
```

```{r}
state <- function(x){
  stateList <- c()
  for(ii in 1:length(x)){
    if(x[ii] < 1){
      stateList <- c(stateList, "dry")
    }
    if(x[ii] >= 1){
      stateList <- c(stateList, "wet")
    }
  }
  return(stateList)
}
weather_data$state <- state(weather_data$Rainfall.amount..millimetres.)
```

```{r}
transitionState <- function(x){
  transitionStateList <- c('') #can't find transition state of first observation
  for(i in 2:length(x)){
    if(x[i] == "dry"){
      if (x[i-1] == "dry"){
        transitionStateList <- c(transitionStateList, "DryToDry")
      }
      else {
        transitionStateList <- c(transitionStateList, "WetToDry")
      }
    }
    if(x[i] == "wet"){
      if (x[i-1] == "dry"){
        transitionStateList <- c(transitionStateList, "DryToWet")
      }
      else {
        transitionStateList <- c(transitionStateList, "WetToWet")
      }
    }
  }
  return(transitionStateList)
}
weather_data$transitionState <- transitionState(weather_data$state)
```

```{r}
train_data <- subset(weather_data, Year >= 2010)
library(ggplot2)
library(RColorBrewer)
# some plots of rainfall data grouped by year and month

ggplot(train_data, aes(x = factor(Month), y = train_data$Rainfall.amount..millimetres., fill = factor(Year))) + 
  geom_bar(stat = "identity") + 
  scale_fill_brewer(palette = "Paired") + 
  xlab("Month")+
  ylab("Rainfall (mm)")+
  labs(fill = "Year")+
  ggtitle("Rainfall of each month. Divided into Years")

ggplot(train_data, aes(x = factor(Year), y = train_data$Rainfall.amount..millimetres., fill = factor(Month))) + 
  geom_bar(stat = "identity") + 
  scale_fill_brewer(palette = "Paired") + 
  xlab("Year")+
  ylab("Rainfall (mm)")+
  labs(fill = "Month")+
  ggtitle("Rainfall of each Year. Divided into Months")
```
```{r}
table(train_data$Month, train_data$Year)
```

```{r}
#Calculating transition state probabilities, in general (no respect to month/season)
weatherTable <- table(train_data$transitionState)

probWetToWet = weatherTable['WetToWet'] / (weatherTable['WetToWet'] + weatherTable['WetToDry'])
probWetToWet

probDryToDry = weatherTable['DryToDry'] / (weatherTable['DryToDry'] + weatherTable['DryToWet'])
probDryToDry
```

```{r}
#Basic generator i hope - no seasonal variation

currentState = "dry" #can make this into a random choice later
                                              #choosing next state depending on probs calculated above
generateRainfallBasic <- function(genLength){
  rainAmountList <- c()
  for (i3 in 1:genLength){
    if (currentState == "dry"){
      if (runif(1) < probDryToDry){
        currentState = "dry"
      }
      else{
        currentState = "wet"
      }
    }
    else if (currentState == "wet"){
      if (runif(1) < probWetToWet){
        currentState = "wet"
      }
      else{
        currentState = "dry"
      }
    }
                                      #generating amount of rainfall if state is wet, else 0
    if (currentState == "wet"){
      rainAmount <- 5*exp(rnorm(1))
      rainAmountList <- c(rainAmountList, rainAmount)
    }
    else{
      rainAmountList <- c(rainAmountList, 0)
    }
  }
  return(rainAmountList)
}
```

```{r, fig.height=10}
#testing basic generator
testRainfall = generateRainfallBasic(3761)
plot(testRainfall)

par(mfrow=c(2,1))
hist(train_data$Rainfall.amount..millimetres.[train_data$Rainfall.amount..millimetres.>1 & train_data$Rainfall.amount..millimetres.<50], xlab = "Actual Rainfall (mm)", main = "Actual Rainfall Frequency Histogram")
hist(testRainfall[testRainfall > 1 & testRainfall <50], xlab = "Simulated Rainfall (mm)", main = "Simulated Rainfall Frequency Histogram")

par(mfrow=c(2,1))
barplot(train_data$Rainfall.amount..millimetres., ylim = c(0,80), main = "Original Data", ylab = "Rainfall (mm)", xlab = "Index")
barplot(testRainfall, ylim = c(0,80), main = "Simulated Data", ylab = "Rainfall (mm)", xlab = "Index")
```

```{r}
#code to calculate transition probabilities for each month

transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #initialising frame by creating 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet') #name da columns

for (i4 in 1:dim(train_data)[1]){ #making dataframe with count of each transition state for each month
  tempTransitionState <- train_data[i4, 'transitionState']
  tempMonth <- train_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```

```{r}
probTransitonStatesMonthsFrame<- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){ #calculating transition probs for each month in df
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
#showing how transition state probabilities vary for each month
plot(probTransitonStatesMonthsFrame$DryToDry, ylim = c(0,1), xlab = "Month", main = "dry to dry transition state probability", type = 'l', ylab = "Probability")
plot(probTransitonStatesMonthsFrame$WetToWet, ylim = c(0,1), xlab = "Month", main = "wet to wet transition state probability", type = 'l', ylab = "Probability")
```
```{r}
#weather generator accounting  for seasonal variation of transition states or something i hope
#yes this is just a spicy version of basic generator it's mostly the same in fact if i forget to even do this it is the same

generateRainfallSeasonal <- function(input){
  currentState = "dry" #can make this into a random choice later
  rainAmountList <- c()
  for (i5 in 1:dim(input)[1]){
    if (currentState == "dry"){
      if (runif(1) < probTransitonStatesMonthsFrame[input[i5, 'Month'], 'DryToDry']){ #now inputs depending on the month of input
        currentState = "dry"
      }
      else{
        currentState = "wet"
      }
    }
    else if (currentState == "wet"){
      if (runif(1) < probTransitonStatesMonthsFrame[input[i5, 'Month'], 'WetToWet']){
        currentState = "wet"
      }
      else{
        currentState = "dry"
      }
    }
                                      #generating amount of rainfall if state is wet, else 0
    if (currentState == "wet"){
      rainAmount <- 5*exp(rnorm(1)) #now log-normal dist, 5 used because is close to mean of weather_data's / the mean of what exp(rnorm(1)) is by default
      rainAmountList <- c(rainAmountList, rainAmount)
    }
    else{
      rainAmountList <- c(rainAmountList, 0)
    }
  }
  return(rainAmountList)
}

```

```{r}
#testing code for seasonal generator
inputSeasonalRainfall <- dplyr::select(train_data, 'Year', 'Month', 'Day') #using existing train data's dates to input to function, instead of putting in just how many to generate

testSeasonalRainfall = generateRainfallSeasonal(inputSeasonalRainfall)
```

```{r}
par(mfrow=c(2,1))
barplot(train_data$Rainfall.amount..millimetres., ylim = c(0,80), main = "Original Data", ylab = "Rainfall (mm)", xlab = "Index")
barplot(testSeasonalRainfall, ylim = c(0,80), main = "Simulated Data - seasonal", ylab = "Rainfall (mm)", xlab = "Index")
```

```{r}
#comparing log-normal against actual data, veeerryyyy close fit, will use log-normal for rainfall sim
p1 <- 5*exp(rnorm(732))
p1 <- p1[p1>1]
hist(p1, breaks = 30, xlim = c(0,120), ylim = c(0,400), main = "Simulated distribution")

p2 <- train_data$Rainfall.amount..millimetres.[train_data$Rainfall.amount..millimetres.>1]
hist(p2, breaks = 30, xlim = c(0,120), ylim = c(0,400), main = "actual distribution")

```

# Testing with sampling - test on a percentage of data

```{r}
set.seed(100345)

sampID <- sample.int(nrow(train_data), size = 0.5*nrow(train_data), replace = FALSE)
train_data <- train_data[sampID,] # 50% of data for training
test_data <- train_data[-sampID,] # 50% for testing
```

```{r}
#code to calculate transition probabilities for each month (copied from earlier)

transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #initialising frame by creating 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet') #name da columns

for (i4 in 1:dim(train_data)[1]){ #making dataframe with count of each transition state for each month
  tempTransitionState <- train_data[i4, 'transitionState']
  tempMonth <- train_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```

```{r}
#also copied from earlier
probTransitonStatesMonthsFrame<- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){ #calculating transition probs for each month in df
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
#generate test data
testSeasonalRainfall50 = generateRainfallSeasonal(train_data)
```
```{r}
par(mfrow = c(2, 1))

barplot(testSeasonalRainfall50, ylab = "Rainfall (mm)", xlab = "index", main = "Simulated data")
barplot(test_data$Rainfall.amount..millimetres., ylab = "Rainfall (mm)", xlab  = "index", main = "Actual data")
```

# use 10 years data (2009-2018) to predict next (2019)
```{r}
train_data <- subset(weather_data, Year >= 2010)
train10_data <- subset(weather_data, Year >= 2009 & Year < 2019)
data_2019 <- subset(weather_data, Year == 2019)
```

```{r}
#code to calculate transition probabilities for each month (copied from earlier)

transitonStatesMonthsFrame <- data.frame(list(rep(0, 12), list(rep(0, 12), list(rep(0, 12), list(rep(0, 12)))))) #initialising frame by creating 12x4 frame filled with zeroes
names(transitonStatesMonthsFrame) <- c('DryToDry', 'DryToWet', 'WetToDry', 'WetToWet') #name da columns

for (i4 in 1:dim(train10_data)[1]){ #making dataframe with count of each transition state for each month
  tempTransitionState <- train10_data[i4, 'transitionState']
  tempMonth <- train10_data[i4, 'Month']
  transitonStatesMonthsFrame[tempMonth, tempTransitionState] <- transitonStatesMonthsFrame[tempMonth, tempTransitionState]+1
}
```
```{r}
#also copied from earlier
probTransitonStatesMonthsFrame<- transitonStatesMonthsFrame
for (i in 1:dim(transitonStatesMonthsFrame)[1]){ #calculating transition probs for each month in df
  
  probTransitonStatesMonthsFrame[i, 'DryToDry'] <- transitonStatesMonthsFrame[i, 'DryToDry'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
  
  probTransitonStatesMonthsFrame[i, 'DryToWet'] <- transitonStatesMonthsFrame[i, 'DryToWet'] / (transitonStatesMonthsFrame[i, 'DryToDry'] + transitonStatesMonthsFrame[i, 'DryToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToDry'] <- transitonStatesMonthsFrame[i, 'WetToDry'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
    
  probTransitonStatesMonthsFrame[i, 'WetToWet'] <- transitonStatesMonthsFrame[i, 'WetToWet'] / (transitonStatesMonthsFrame[i, 'WetToDry'] + transitonStatesMonthsFrame[i, 'WetToWet'])
}
```

```{r}
# using month probabilites generate one years worth of data 
monthList <- subset(weather_data, Year == 2011) # a year that isn't a leap year to get the month list, as generation algorithm only requires months
monthList <- monthList['Month']
testSeasonalRainfall10 <- generateRainfallSeasonal(monthList)
```

```{r, fig.height=9}
#compare generated year against 2019
par(mfrow = c(2,1))
barplot(testSeasonalRainfall10, xlab = "Index", ylab = "Rainfall (mm)", main = "Simulated Rainfall")
barplot(data_2019$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2019 Rainfall")


# check other years for comparison
par(mfrow = c(3,2))
barplot(testSeasonalRainfall10, xlab = "Index", ylab = "Rainfall (mm)", main = "Simulated Rainfall")
year <- subset(weather_data, Year == 2015)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2015 Rainfall")
year <- subset(weather_data, Year == 2008)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2008 Rainfall")
year <- subset(weather_data, Year == 2017)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2017 Rainfall")
year <- subset(weather_data, Year == 2007)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2007 Rainfall")
year <- subset(weather_data, Year == 2013)
barplot(year$Rainfall.amount..millimetres., xlab = "Index", ylab = "Rainfall (mm)", main = "2013 Rainfall")
rm(year)
```

```{r}
temp <- subset(weather_data, weather_data$state == "wet")
mean(temp$Rainfall.amount..millimetres.)
rm(temp)
```


# attemp to find patterns
```{r}
# create graph of difference in rainfall for years, weeks, months, years to see if there are any potnetial patters.

# create a list of the weekly rainfall
RainfallWeekly <- data.frame("Rainfall (mm)", "Week")
colnames(RainfallWeekly) <- c("Rainfall (mm)", "Week")
RainfallWeekly$`Rainfall (mm)` <- as.numeric(RainfallWeekly$`Rainfall (mm)`)
RainfallWeekly$Week <- as.numeric(RainfallWeekly$Week)
week = 1
weekRain = 0
for(ii in c(1: nrow(weather_data))){
  weekRain = weekRain + weather_data[ii, 6] # rainfall amount for that row
  
  if(ii%%7 == 0){ # every 7th row
    RainfallWeekly[(ii/7), 1] <- weekRain # 1 row of RainfallWeekly created every 7 rows (1 weeks) - inserting rainfall total for that week
    RainfallWeekly[(ii/7), 2] <- week
    week = week + 1
    weekRain = 0 # clear total rainfall to prepare for next week
  }
}
```

```{r}
RainfallWeeklyDiff <- data.frame(c(1:(nrow(RainfallWeekly)-1)), c(1:(nrow(RainfallWeekly)-1))) # data frame with two columns, one less row than RainfallWeekly
colnames(RainfallWeeklyDiff) <- c("Rainfall diff (mm)", "Week")
RainfallWeeklyDiff$`Rainfall diff (mm)` <- diff(RainfallWeekly$`Rainfall (mm)`) # change in weeks
```
```{r, fig.height= 14}
# plot first 700 weeks first against the difference in rainfall, and then the rainfall per week
par(mfrow = c(4,1))
plot(RainfallWeeklyDiff[c(1:350), 2], RainfallWeeklyDiff[c(1:350), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(1:350), 2], RainfallWeekly[c(1:350), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
plot(RainfallWeeklyDiff[c(351:700), 2], RainfallWeeklyDiff[c(351:700), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(351:700), 2], RainfallWeekly[c(351:700), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")

```

```{r, fig.height= 14}
# plot second 700 weeks first against the difference in rainfall, and then the rainfall per week
par(mfrow = c(4,1))
plot(RainfallWeeklyDiff[c(701:1050), 2], RainfallWeeklyDiff[c(701:1050), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(701:1050), 2], RainfallWeekly[c(701:1050), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
plot(RainfallWeeklyDiff[c(1051:1414), 2], RainfallWeeklyDiff[c(1051:1414), 1], xlab = "week", ylab = "change in rainfall (mm)", cex = 2, type = "b")
plot(RainfallWeekly[c(1051:1414), 2], RainfallWeekly[c(1051:1414), 1], xlab = "week", ylab = "rainfall (mm)", type = "l")
```

Have to do wilcoxon ranked test.
